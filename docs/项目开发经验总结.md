# 🏗️ 茂名文旅项目开发经验总结

**文档版本**: v1.0  
**创建日期**: 2026-02-14  
**适用项目**: 类似的多端（移动端+PC端）业务系统

---

## 📋 项目概述

### 项目基本信息

| 项目 | 茂名交投文旅平台 |
|------|------------------|
| **业务类型** | 文旅服务平台（景点、民宿、拼车、资讯、商城） |
| **技术架构** | 前后端分离 + 多端应用 |
| **开发周期** | 持续迭代开发 |
| **团队规模** | 小型团队（2-3人） |

### 技术栈选型

| 端 | 技术栈 | 选型理由 |
|----|--------|----------|
| **后端** | Node.js + Prisma + MySQL | 快速开发、类型安全、ORM方便 |
| **PC管理端** | Vue3 + Element Plus | 成熟的企业级UI框架 |
| **移动端H5** | Vue3 + Vant | 轻量级、适合移动端 |
| **小程序** | 微信原生 | 平台要求 |
| **部署** | Docker + 阿里云ACR | 标准化、易维护 |

---

## 一、架构设计经验

### 1.1 多端架构设计

**核心原则**: 一套后端服务，多端共用

```
┌─────────────────────────────────────────────────────────┐
│                      统一后端API                          │
│              (Node.js + Prisma + MySQL)                   │
└──────────────────┬──────────────────────────────────────┘
                   │
       ┌───────────┼───────────┐
       ▼           ▼           ▼
┌──────────┐ ┌──────────┐ ┌──────────┐
│  移动端H5 │ │ PC管理端 │ │  小程序   │
│ (Vue3)   │ │ (Vue3)   │ │ (原生)   │
└──────────┘ └──────────┘ └──────────┘
```

**经验总结**:
- ✅ 统一后端API，避免重复开发
- ✅ 按业务场景划分API端点（/api/mobile/*, /api/pc/*）
- ⚠️ 注意：移动端和PC端的权限控制不同
- ⚠️ 注意：移动端和PC端的数据展示维度不同

### 1.2 数据库设计经验

#### 核心业务表设计

| 业务模块 | 核心表 | 关联表 | 经验 |
|---------|--------|--------|------|
| 拼车 | Carpool | Order, CarpoolRoute | 订单表独立，支持多种支付方式 |
| 景点 | Attraction | AttractionImage | 图片单独存储，支持多图 |
| 民宿 | Homestay | HomestayRoom | 房型单独管理 |
| 资讯 | Article | ArticleCategory | 分类管理 |

#### 支付功能设计（重要经验）

**设计演进**:
```
初期: 拼车表直接存支付信息
     ↓ 问题：无法支持多种支付方式，无法扩展
改造: 独立Order表
     ↓ 优势：支持在线支付、二维码支付，可扩展
最终: Carpool + Order 关联
     ↓ 优势：业务与支付分离，支持退款
```

**关键设计决策**:
1. **Order表独立**: 不直接存在Carpool表，而是独立表关联
2. **支付场景字段**: `pay_scene` 区分不同业务场景
3. **支付方式字段**: `pay_method` 区分在线支付/二维码支付
4. **状态分离**: Carpool状态（业务）和 Order状态（支付）分开管理

**经验总结**:
- ✅ 支付相关表必须独立，不与业务表耦合
- ✅ 支持多种支付方式时，预留扩展字段
- ✅ 状态变更需要记录时间戳和操作人
- ⚠️ 注意：历史数据迁移问题（新增Order表后，历史Carpool需要补数据）

### 1.3 API设计规范

#### 成功响应格式
```javascript
{
  code: 200,
  message: "success",
  data: { /* 业务数据 */ }
}
```

#### 错误响应格式
```javascript
{
  code: 400/401/404/500,
  message: "具体错误信息",
  error: { /* 详细错误信息（可选）*/ }
}
```

#### 分页响应格式
```javascript
{
  code: 200,
  data: {
    list: [ /* 数据列表 */ ],
    pagination: {
      page: 1,
      pageSize: 10,
      total: 100,
      totalPages: 10
    }
  }
}
```

**经验总结**:
- ✅ 统一响应格式，前端处理逻辑可以复用
- ✅ HTTP状态码和业务code分离
- ✅ 错误信息必须具体，便于排查问题
- ⚠️ 注意：移动端和PC端的分页需求可能不同

---

## 二、开发过程经验

### 2.1 时间处理规范（重要！）

**问题背景**: 项目初期出现时区混乱问题，导致订单时间显示不正确

**解决方案**: 统一使用北京时间（Asia/Shanghai, UTC+8）

**规范要点**:

| 端 | 规范 | 示例 |
|----|------|------|
| 后端 | 生成北京时间存储 | `dayjs().tz('Asia/Shanghai').format()` |
| 前端 | 直接使用，不转换 | `{{ item.created_at }}` |
| 数据库 | DATETIME类型，+8时区 | `SET time_zone = '+8:00'` |

**经验总结**:
- ✅ 所有业务时间必须使用北京时间
- ✅ 后端统一处理时间生成
- ✅ 前端禁止时区转换
- ✅ Docker容器必须设置时区
- ⚠️ 教训：时区问题越早规范越好，后期改造成本高

**文档沉淀**: `docs/TIMEZONE.md`

### 2.2 前后端字段命名规范

**问题背景**: 前后端字段命名不一致，导致数据绑定问题

**规范制定**:

| 场景 | 规范 | 示例 |
|------|------|------|
| 数据库 | snake_case | `created_at`, `user_name` |
| 后端JS | camelCase | `createdAt`, `userName` |
| API返回 | snake_case | `created_at` |
| 前端 | camelCase | `createdAt` |

**Prisma映射**:
```prisma
model User {
  id         Int      @id @default(autoincrement())
  userName   String   @map("user_name")  // 数据库用snake_case
  createdAt  DateTime @default(now()) @map("created_at")
}
```

**经验总结**:
- ✅ Prisma的@map字段可以自动处理命名转换
- ✅ API层统一使用snake_case（与数据库一致）
- ✅ 前端接收到数据后转换为camelCase
- ⚠️ 教训：项目初期就要约定命名规范

### 2.3 图片上传与存储

**方案选型**:
- 开发环境：本地存储
- 生产环境：阿里云OSS

**关键经验**:

| 环境 | 存储方式 | 访问方式 | 注意点 |
|------|----------|----------|--------|
| 开发 | 本地public目录 | 相对路径 | 需要同步到生产 |
| 生产 | 阿里云OSS | 完整URL | 需要配置跨域 |

**代码实现**:
```javascript
// 上传接口统一处理
const uploadImage = async (file) => {
  if (process.env.NODE_ENV === 'development') {
    // 本地存储
    return '/uploads/' + filename
  } else {
    // OSS上传
    return 'https://hxcm-oss.oss-cn-shenzhen.aliyuncs.com/' + filename
  }
}
```

**经验总结**:
- ✅ 上传逻辑封装统一接口，环境判断在服务端
- ✅ 生产环境必须使用CDN加速
- ⚠️ 注意：OSS Bucket权限配置（私有/公共读）
- ⚠️ 注意：图片尺寸限制和压缩处理

### 2.4 双端数据同步机制

**业务场景**: 移动端发起拼车，PC端管理订单

**数据流设计**:
```
移动端创建 → 后端存储 → PC端查询
     ↑                         ↓
移动端查询 ← 后端同步 ← PC端修改状态
```

**关键实现**:

1. **状态变更触发**
```javascript
// PC端修改状态
await prisma.carpool.update({
  where: { id },
  data: { status: 'confirmed' }
})

// 同时更新Order（如果需要）
await prisma.order.updateMany({
  where: { carpoolId: id },
  data: { status: 'paid' }
})
```

2. **移动端实时性**
```javascript
// 移动端进入页面刷新
onMounted(() => {
  fetchCarpoolList()
})

// 列表下拉刷新
const onRefresh = async () => {
  await fetchCarpoolList()
}
```

**经验总结**:
- ✅ 状态变更在后端事务中完成，保证一致性
- ✅ 移动端进入页面时刷新数据
- ✅ 关键操作后手动刷新（如支付后）
- ⚠️ 注意：避免频繁轮询，考虑WebSocket或长轮询

---

## 三、测试经验

### 3.1 测试策略

**分层测试**:

| 层级 | 测试类型 | 工具 | 执行时机 |
|------|----------|------|----------|
| 单元测试 | 函数/组件测试 | Jest/Vitest | 开发阶段 |
| 集成测试 | API测试 | Postman | 联调阶段 |
| E2E测试 | 端到端测试 | Playwright | 提测前 |
| 人工测试 | 业务场景测试 | - | 上线前 |

**实际执行**（基于2026-02-14测试实践）:

1. **自动化初筛** (Playwright)
   - 全页面可访问性检查
   - 控制台错误捕获
   - 全页面截图

2. **PC端功能遍历**
   - 左侧菜单逐个点击
   - 右侧标签页检查
   - 控制台监控

3. **移动端核心流程**
   - 首页 → 功能入口 → 表单 → 提交

4. **双端联动测试**（重点）
   - 移动端操作 → PC端验证
   - PC端操作 → 移动端验证
   - 使用真实订单测试（#56, #58）

5. **边界条件测试**
   - 列表刷新
   - 标签状态保持
   - 空数据处理

**经验总结**:
- ✅ 双端联动测试是发现同步问题的关键
- ✅ 使用真实业务数据测试（而非测试数据）
- ✅ 完整的业务流程测试（创建→支付→退款）
- ⚠️ 教训：自动化测试覆盖率不足，需要补充

**文档沉淀**: `docs/测试规范指引.md`

### 3.2 常见问题及解决方案

| 问题 | 现象 | 原因 | 解决方案 |
|------|------|------|----------|
| 组件识别问题 | 已选时间但提示未选 | 组件状态未正确绑定 | 检查v-model绑定，确保组件正确识别 |
| 列表未刷新 | 操作后列表未更新 | 未重新请求数据 | 操作成功后手动刷新列表 |
| 标签未保持 | 返回后标签重置 | 未保存标签状态 | 使用query参数或localStorage保存状态 |
| 401错误 | 保存时返回401 | Token过期 | 检查Token有效期，自动刷新机制 |
| 404错误 | 接口返回404 | 路由未定义或参数错误 | 检查后端路由定义，确认参数传递正确 |
| 过滤器宽度问题 | 组件显示异常 | 响应式布局问题 | 设置最小宽度，使用flex布局 |

---

## 四、部署经验

### 4.1 Docker部署架构

```
┌─────────────────────────────────────────────────────────┐
│                     阿里云ECS服务器                      │
│  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐        │
│  │  Backend    │ │ Mobile H5   │ │ PC Admin    │        │
│  │  :3000      │ │  :8080      │ │  :8081      │        │
│  └─────────────┘ └─────────────┘ └─────────────┘        │
│                                                          │
│  ┌─────────────────────────────────────────────────┐    │
│  │              Nginx 反向代理                      │    │
│  │  80 / 443 → 各服务                               │    │
│  └─────────────────────────────────────────────────┘    │
└─────────────────────────────────────────────────────────┘
```

### 4.2 镜像构建经验

**重要经验：架构匹配**

| 环境 | 架构 | 说明 |
|------|------|------|
| 本地开发 | ARM64 (Mac M系列) | Apple Silicon |
| 生产服务器 | AMD64 (x86_64) | 阿里云ECS |

**问题**: 本地构建的ARM64镜像无法在AMD64服务器运行

**解决方案**:
```dockerfile
# ✅ 正确：明确指定AMD64
FROM node:20-alpine-amd64

# ❌ 错误：使用默认镜像（本地可能是ARM64）
FROM node:20-alpine
```

**验证命令**:
```bash
docker inspect <镜像名> --format '{{.Architecture}}'
# 应该输出: amd64
```

### 4.3 部署流程

**标准流程**:
```bash
# 1. 构建（本地或CI）
docker build -t <镜像名> .

# 2. 推送阿里云ACR
docker push <仓库地址>/<镜像名>:<tag>

# 3. 服务器拉取
docker pull <仓库地址>/<镜像名>:<tag>

# 4. 重启服务
./scripts/deploy-<服务名>.sh
```

**自动化脚本**:
```bash
# scripts/deploy-backend.sh
#!/bin/bash
docker stop xinyi-wenlu-backend
docker rm xinyi-wenlu-backend
docker pull <镜像地址>
docker run -d --restart=always --name xinyi-wenlu-backend -p 3000:3000 <镜像地址>
```

**经验总结**:
- ✅ 每个服务独立部署脚本
- ✅ 使用`--restart=always`确保服务自动重启
- ✅ 部署后检查`docker ps`确认状态
- ⚠️ 注意：部署前备份数据库（重要！）
- ⚠️ 注意：环境变量通过`-e`注入，不硬编码在镜像中

### 4.4 环境变量管理

**环境分离**:

| 环境 | 文件 | 说明 |
|------|------|------|
| 开发 | `.env.development` | 本地开发配置 |
| 生产 | `.env.production` | 生产环境配置 |
| 示例 | `.env.example` | 配置模板（无敏感信息） |

**敏感信息处理**:
```bash
# 生产环境敏感信息通过Docker -e注入
docker run -e DATABASE_URL="mysql://..." -e JWT_SECRET="..." <镜像>

# 不在代码仓库中提交真实配置
echo ".env.production" >> .gitignore
```

---

## 五、项目管理经验

### 5.1 需求管理

**需求分类**:

| 类型 | 处理方式 | 示例 |
|------|----------|------|
| 新功能 | 需求评审 → 技术方案 → 开发 → 测试 | 支付功能改造 |
| Bug修复 | 问题记录 → 分析原因 → 修复 → 验证 | 组件识别问题 |
| 优化项 | 评估优先级 → 排期开发 | 列表显示订单号 |

**文档沉淀**:
- 功能方案文档：`docs/支付功能改造方案.md`
- 完成总结：`docs/支付功能改造完成总结.md`
- 测试记录：`memory/2026-02-14-testing.md`

### 5.2 问题追踪

**问题记录模板**:
```markdown
| 问题描述 | 模块 | 状态 | 处理人 |
|---------|------|------|--------|
| [具体现象] | [模块名] | 🔧修复中/✅已修复 | [负责人] |
```

**状态流转**:
```
发现 → 记录 → 分配 → 修复 → 验证 → 关闭
```

**经验总结**:
- ✅ 问题必须记录，口头沟通容易遗漏
- ✅ 明确处理人和截止时间
- ✅ 修复后必须验证，不能假设修好
- ✅ 关联问题需要一起验证

### 5.3 代码审查

**审查要点**:

| 方面 | 检查内容 |
|------|----------|
| 功能 | 是否实现需求，边界条件处理 |
| 代码质量 | 命名规范、代码复用、注释 |
| 安全性 | SQL注入、XSS、权限控制 |
| 性能 | 数据库查询优化、N+1问题 |
| 兼容性 | 移动端适配、浏览器兼容 |

---

## 六、技术债务与改进

### 6.1 已知技术债务

| 问题 | 影响 | 改进计划 |
|------|------|----------|
| 历史数据迁移 | 新增Order表后，历史Carpool无Order记录 | 编写脚本批量创建 |
| 自动化测试覆盖不足 | 回归测试依赖人工 | 补充Playwright测试用例 |
| 缺少API文档 | 前后端沟通成本高 | 引入Swagger自动生成 |
| 日志管理不规范 | 排查问题困难 | 统一日志格式，引入日志收集 |

### 6.2 架构演进思考

**当前架构**:
```
单体后端 + 多前端
```

**未来考虑**:
```
微服务拆分（业务增长后）
- 用户服务
- 订单服务
- 支付服务
- 内容服务
```

**触发条件**:
- 单表数据量超过1000万
- 某个模块变更频繁影响其他模块
- 团队规模扩大，需要并行开发

---

## 七、给其他项目的建议

### 7.1 项目启动阶段

1. **技术选型**
   - 优先选择团队熟悉的技术栈
   - 考虑社区活跃度和长期维护
   - 评估学习成本

2. **架构设计**
   - 预留扩展接口（如支付模块）
   - 确定命名规范（数据库、API、代码）
   - 制定时间处理规范（时区！）

3. **开发规范**
   - 代码格式化（ESLint/Prettier）
   - Git提交规范（commit message）
   - 分支管理策略（Git Flow）

### 7.2 开发阶段

1. **功能开发**
   - 先写方案文档，再写代码
   - 复杂功能先画流程图
   - 重要功能写单元测试

2. **联调测试**
   - 前后端约定API后再开发
   - 使用Postman集合共享API
   - 定期同步进度，及时发现问题

3. **文档维护**
   - 代码即文档（命名清晰）
   - 复杂逻辑加注释
   - 功能完成写总结文档

### 7.3 上线阶段

1. **部署准备**
   - 准备部署脚本
   - 测试环境预演
   - 数据备份策略

2. **监控报警**
   - 服务健康检查
   - 错误日志收集
   - 性能监控

3. **应急预案**
   - 回滚方案
   - 故障处理流程
   - 联系人清单

---

## 八、总结

### 做得好的地方 ✅

1. **双端联动测试**：发现了许多数据同步问题
2. **文档沉淀**：形成了时间规范、测试规范等文档
3. **支付功能设计**：独立Order表，支持多种支付方式
4. **Docker化部署**：标准化流程，减少环境问题

### 需要改进的地方 ⚠️

1. **自动化测试**：覆盖率不足，依赖人工测试
2. **历史数据迁移**：新增表后历史数据处理不及时
3. **API文档**：前后端沟通成本高，缺少自动化文档
4. **性能优化**：大数据量场景未做充分测试

### 给其他项目的核心建议 💡

1. **时区问题**：项目初期就必须规范，后期改造成本极高
2. **支付设计**：必须独立表设计，预留扩展性
3. **测试策略**：双端联动测试必不可少
4. **文档习惯**：好记性不如烂笔头，文档是团队的记忆

---

**相关文档索引**:
- 时间规范：`docs/TIMEZONE.md`
- 测试规范：`docs/测试规范指引.md`
- 支付改造方案：`docs/支付功能改造方案.md`
- 支付改造总结：`docs/支付功能改造完成总结.md`
- 测试记录：`memory/2026-02-14-testing.md`
- 测试总结：`memory/2026-02-14-testing-summary.md`

---

**维护说明**: 本文档根据项目实际开发经验总结，后续可根据新项目实践持续更新优化。
